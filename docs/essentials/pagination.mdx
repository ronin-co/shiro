---
title: 'Pagination'
icon: 'page'
---

When retrieving multiple records (such as using `get.accounts`), a maximum of 20 records are returned at once.

This limit ensures that memory overflows are avoided by default. This means there cannot be a scenario where your queries retrieve so many records that the memory available to the receiving application (such as a Docker container or Worker function) fills up, and the application crashes.

Furthermore, always returning the same amount of records within your application (rather than returning more records if there are more available) ensures consistent response times, as the response time does not depend on how many records are being provided. Like this, you will be able to track and improve your app’s performance much more easily.

To retrieve more than 20 records, making use of “pagination” is advised, which means additional records are loaded on demand. If your application provides a UI, this may, for example, manifest in the following two ways:

- The user looking at the list of records may request more by clicking on “Next Page” ("Classic Pagination").

- The user looking at the list of records may request more by scrolling downward ("Infinite Scroll").

Which of these implementations (or any other) you may choose is up to you.

## Retrieving the Next Page

When running a query such as `get.accounts` while more than 20 records are available for the respective model, a `moreAfter` property will be provided to you (the property only exists if more than 20 records are available; otherwise it is not defined).

This property contains a so-called “cursor” pointing to the next page of records, which is effectively a string identifying the next page:

```ts
const accounts = await get.accounts();

// Contains the cursor of the next page.
accounts.moreAfter;
```

Whenever you would like to load more records, you can then define the value of `moreAfter` in a separate query, and you will be provided with the next 20 records:

```ts
const moreAccounts = await get.accounts.after(accounts.moreAfter);

// Contains the cursor of the next page.
moreAccounts.moreAfter;
```

You can repeat the above as often as you want to until there are no more records available (in which case `moreAfter` will not be defined anymore). Every time you run the query, a new `moreAfter` cursor value will be provided to you.

## Retrieving the Previous Page

If you would like to implement bi-directional pagination, you may use the `before` instruction and its `moreBefore` counterpart, which behave exactly the same as `after` and `moreAfter`, except that they let you paginate “upwards” instead of “downwards”:

```ts
const moreAccounts = await get.accounts.before(accounts.moreBefore);

// Contains the cursor of the next page (upwards).
moreAccounts.moreBefore;
```

For example, this would be useful if you’ve implemented a page that shows a specific range of records that still has more records before and after it in the database, which aren’t displayed. You could then use `before` to reveal more of the “previous records” in the list.

## Customizing the Page Length

By default, 20 records are provided per page and more records can be obtained by paginating them, meaning by loading more pages, as described in the sections above.

However, in special cases in which you would like to retrieve more than 20 records from your database without having to load multiple pages, you may decide to use the `limitedTo` instruction to provide a custom page length:

```ts
await get.accounts.limitedTo(50);
```

As with other query instructions, `limitedTo` can be combined with the `after` and `before` instructions used for retrieving a specific page of records like so:

```ts
await get.accounts({
  after: '...',
  limitedTo: 100,
});
```

## Considerations

If you would like to display an infinite amount of records in your UI (for example displaying the list of members of a team in your app, which might be allowed to be infinite), we strongly recommend using pagination due to the reasons mentioned at the top of this page. In those cases, you should therefore only resort to `limitedTo` if you want to decrease or increase the page size slightly, not to retrieve all records.

If, however, there is a guarantee within the conceptual model of your application that a certain kind of record can only exist a finite amount of times (or to be specific, only a finite amount or less than that is always displayed), you may decide to use `limitedTo` in order to retrieve all records at once.

The maximum value allowed by `limitedTo` (the maximum page length) is `1000`. We strongly advice against making use of such a high value unless truly necessary, since loading more records means that the memory usage of your application increases linearly with the amount of records loaded.

Especially considering that every user of your application may load a different list of records, loading all records at once may lead to a situation where the memory usage of your application is not predictable anymore, which may lead to crashes or other performance issues.